TODO:
- Implement HOG

Steps for mask:
- Download the frozen graph (contains weights)
- Use optimize_for_inference
- Use graph transformation tool
- Use tf_text_graph to convert it into graph.pbtxt which is the structure of the network as layers

HOG_SVM:
- The image is first gamma corrected to decrease the effect of illumination; especially for shadows, yet it is not very
effective for hard shadows, therefore a shadow removal process can also be helpful
- Using pixel blocks of size 8x8, go over the image to generate gradient vectors for each pixel where they are used to
create a histogram of angles, which are bins of angles (in the paper it is 180 degrees with 9 bins; 20 degrees for each)
- The gradients are then normalized in order to tackle illumination differences
- For blocks, 2x2 seems to be the best
- For SVM part, there is hit-threshold which is the distance for SVM plane to have to closest feature point.
We made it 0 which enables usage of all features (?)
- THe size of the sliding window is also crucial as making it too large will miss some pedestrians.
- Adding some padding as multiplies of 8 would increase our accuracy
- The scale determines the scaling in the pyramid of image (which are optionally blurred) which enables our detector
to find variable sized pedestrians. Decreasing it would increase the total time of the process but would improve
the number of detections, which is more crucial for our case.
-The ‘finalThreshold’ parameter is mainly used to select the clusters that have at least ‘finalThreshold + 1’ rectangles
 This parameter is passed as an argument to groupRectangles() or groupRectangles_meanShift()(when meanShift is enabled)
 function which rejects the small clusters containing less than or equal to ‘finalThreshold’ rectangles, computes the
 average rectangle size for the rest of the accepted clusters and adds those to the output rectangle list.
 - SO final threshold rejects low density of clusters
 - Meanshift is suggested by the paper to combine overlapping bounding boxes. Usage of non-maxima suppresssion is preferred

 NMS: (RNN only)
 - Greedy approach just checks for intersecting areas and combines them.
 - Im not sure if the OpenCV one implements the paper: https://www.vision.ee.ethz.ch/publications/papers/proceedings/eth_biwi_01126.pdf
 The documentation is not very clear and I don't really want to read its paper

 Background subtraction:






Tensorflow:
API for Neural networks where you can construct them using layer definitions.

Notes on RNN (Residual Neural Networks):

Paper (cite):

Comparison (Mobilenet, inception, hog):
- Read speed comparison: https://realpython.com/numpy-tensorflow-performance/
- Side-by-side comparison of detection on a single window
- 1-Recall = FalseNeg / (TruePos + FalseNeg) and precision